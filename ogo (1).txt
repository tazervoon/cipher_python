Версия 1

Скрипт пишется на языке Python версии 3.10.

Особенности выполнения
Скрипт выполняется не из файла (без записи на диск). Из-за этого:

технически, текст скрипта не может занимать больше 128 КиБ, иначе он не запустится;
исключения не выдают текст строки, а лишь её номер.
Сам скрипт выполняется из директории ~/ips3-sandbox, и вы можете читать и записывать файлы в эту директорию. Не забудьте сохранить нужные вам файлы в конце рабочей сессии!

Базовый скрипт
import ips  # 1
psm = ips.init()  # 2

# ... здесь ваш код ...

psm.save_and_exit()  # 3

# команда 3 завершает скрипт,
# после неё приказы не выполнятся
Импорт библиотеки API стенда.
Запрос на сервер и создание объекта с данными активного хода.
Отправка сформированных приказов на сервер и завершение скрипта. Без этой команды скрипт бесполезен.
Получение данных
Каждый такт скрипт получает данные из энергосистемы, и они размещаются в соответствующих полях объекта psm.

Объекты энергосети
Объекты помещены в поле objects и представляют собой список объектов, хранящих данные соответствующего объекта.

for obj in psm.objects:
    print("== Объект:", obj.id, "==") # (тип, номер)
    print("Тип: ", obj.type) # str, см. ниже
    print("Включен:", obj.power.now.online) # bool
    print("Тариф:", obj.contract) # float
    print("Адрес:", obj.address) # [str]
    print("Энергорайоны:",
          obj.path) # [ <адрес энергорайона> ]
    print("Доход:",
          obj.score.now.income) # float
    print("Расход:",
          obj.score.now.loss) # float
    print("Доход за первый ход:",
          obj.score.then[0].income)
    print("Расход за 5ый ход:",
          obj.score.then[4].loss) # float
    print("Генерация:",
          obj.power.now.generated) # float
    print("Потребление:",
          obj.power.now.consumed) # float
    print("Потребление за первый ход:",
          obj.power.then[0].consumed)
    print("Заряд (актуально для накопителя):",
          obj.charge.now) # float
    print("Штормовой режим (актуально для ВЭС):",
          obj.failed) # bool
    print("Угол (актуально для КСЭС):",
          obj.angle) # аналогично power

# обозначения типов объектов
obj_types = [
    "main" # подстанции
    "miniA", # мини-подстанции А
    "miniB", # мини-подстанции Б
    "houseA", # дом А
    "houseB", # дом Б (офисный центр)
    "factory", # заводы
    "storage", # накопители
    "wind", # ветровые электростанции
    "solar", # солнечные электростанции
    "solarRobot", # кибер-СЭС
    "tps", # ТЭС
]
Энергорайоны (нумерация с 1)
Энергорайоны помещены в поле networks и представляют собой словарь, где ключи — индексы (нумеруются с 1!), а значения — структуры, хранящие в себе информацию о соответствующих районах (состояние, показатели).

for index, net in psm.networks.items():
    print("== Энергорайон", index, "==")
    print("Адрес:", net.location)
          # [ (ID подстанции, № линии) ]
    print("Включен:", net.online) # bool
    print("Генерация:", net.upflow) # float
    print("Потребление:", net.downflow) # float
    print("Потери:", net.losses) # float
    print("Износ: ", net.wear) # int
    print("Перегрузка: ", net.overloaded) # bool
Прогнозы
На каждую величину (потребление и погода) дано по несколько прогнозов. Доступ к ним осуществляется через поле forecasts, после чего идёт обращение к типу прогнозов и индекс прогноза.

Каждый прогноз является последовательностью медиан, при это известно максимальное отклонение значения от медианы. Это отклонение общее для всех прогнозов этого типа.

# дом А, 1ый ход
x = psm.forecasts.houseA[0]
# дом Б, 11ый ход
x = psm.forecasts.houseB[10]
# завод, 6ой ход
x = psm.forecasts.factory[5]
# солнце на востоке, район M56, 2ой ход
x = psm.forecasts.sunEast["M56"][1]
# солнце на западе, район M56, 12ый ход
x = psm.forecasts.sunWest["M56"][11]
# ветер, район M12, 3ий ход
x = psm.forecasts.wind["M12"][2]

# максимальное отклонение прогноза для района M34
spr = psm.forecasts.wind["M34"].spread
Погода
print("Сила ветра в районе M56:", psm.wind["M56"].now) # float
print("Была на 1 ходу:", psm.wind["M56"].then[0]) # float

print("Текущая яркость солнца на западе в районе M12:",
      psm.sunWest["M12"].now) # float
print("Яркость солнца на востоке в районе M12 на 5 ходе:",
      psm.sunEast["M12"].then[4]) # float
Биржа
print("Фактические контракты:")
for receipt in psm.exchange:
    print("Контрагент:", receipt.source)
    # "exchange" = оператор,
    # "fill"     = аноним,
    #     иначе  = другой игрок
    print("Объём:", receipt.flux)
    # Плюс = покупка, минус = продажа
    print("Цена за МВт:", receipt.price)
    print("")
Игрок представлен словарём с ключами place и player.

История тарифов на бирже
# минимальный тариф за энергию
x = psm.exchangeLog[10].min
# максимальный тариф за энергию
x = psm.exchangeLog[10].max
# все примеры для 11-го хода
Прочая информация
Эти поля из объекта стенда не связаны с важными данными, но тоже могут пригодиться.

print("Ход:",  psm.tick)  # int
print("Всего ходов:",  psm.gameLength)  # int
print("Изменение счёта:", psm.scoreDelta)  # float

print("Всего сгенерировано:",
      psm.total_power.generated) # float
print("Всего потреблено:",
      psm.total_power.consumed) # float
print("Получено с биржи (минус = отправлено):",
      psm.total_power.external) # float
print("Всего потерь:",
      psm.total_power.losses) # float
print("Текущая сумма налогов:",
      psm.greenMoney) # float
print("Текущая сумма эко-баллов:",
      psm.greenPoints) # float
Приказы
Для управления энергосистемой используются управляющие воздействия (приказы). Вы можете объявлять их с помощью функций из psm.orders. При корректном завершении скрипта (psm.save_and_exit()) эти приказы отправляются в систему.

Приоритет приказов:

Линии — выполняется последний отправленный
Угол КСЭС — выполняется последний отправленный
ТЭС – выполняется последний отправленный
Накопитель — складываются
Биржа — выполняются все по отдельности
Отмена приказов не предусмотрена!

Все числовые параметры в приказах, кроме данных в графике — ненулевые положительные!

# Отправить 10 МВт в накопитель c3
psm.orders.charge("c3", 10)

# Забрать 5 МВт из накопителя c1
psm.orders.discharge("c1", 5)

# Включить линию 2 на подстанции М2
psm.orders.line_on("M2", 2)

# Выключить линию 1 на мини-подстанции m1
psm.orders.line_off("m1", 1)

# Заявка на продажу 10,2 МВт за 2,5 руб./МВт
psm.orders.sell(10.2, 2.5)

# Заявка на покупку 5,5 МВт за 5,1 руб./МВт
psm.orders.buy(5.5, 5.1)

# Выставить угол КСЭС r5 на 75%
psm.orders.robot("r5", 75)

# Сжечь 5 ед. топлива в ТЭС t4
psm.orders.tps("r4", 4)
Отладка
Для локальной проверки и отладки скрипта можно использовать локальную среду IDLE со встроенным модулем ips.

В модуле реализованы команды:

Для замены init():
init_test() — данные из вшитого примера
from_json(json_str) — данные из JSON-string
from_file(filename) — данные из файла в JSON-формате
В дополнение к Powerstand.save_and_exit (без сервера он не выполняется):
print(psm.get_user_data()) — вывод данных из пользовательских графиков
print(psm.orders.get()) — вывод приказов в чистом виде в stdout без завершения скрипта
print(psm.orders.humanize()) — то же самое, но приказы представлены в читаемом виде
Пример отладочной версии скрипта и правок для получения оной:

import ips

# psm = ips.init()  # было
psm = ips.init_test() # стало

# ... здесь ваш код ...

print("\n".join(psm.orders.humanize()))
# графики в приказах не приводятся, но можно так:
print(psm.get_user_data())

# строку можно оставить, отправка в систему
# не производится, только выход из скрипта
psm.save_and_exit()
